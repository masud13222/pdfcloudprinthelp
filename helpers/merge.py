from pyrogram import Client, filters
from pyrogram.types import Message
import os
import pikepdf
import time
import humanize
import asyncio
from typing import Dict, List
import sys

# Import state from state.py
from .state import user_states, status_messages, message_locks, last_progress_update, PDFMerger
from .constants import DOWNLOAD_DIR

# Constants
MAX_FILES = 20  # Maximum number of files
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB per file
MAX_MERGED_SIZE = 1024 * 1024 * 1024  # 1GB merged file
UPDATE_INTERVAL = 5  # Update progress every 5 seconds

sys.setrecursionlimit(10000)  # Increase recursion limit

def get_status_text(merger: PDFMerger, current=0, total=0, start_time=None, file_num=None, total_files=None, status="waiting") -> str:
    """Generate status message text."""
    if status == "waiting":
        files_received = len(merger.pdf_files)
        files_remaining = merger.required_files - files_received
        return (
            f"üìë **PDF ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏**\n\n"
            f"‚Ä¢ ‡¶ó‡ßÉ‡¶π‡ßÄ‡¶§: {files_received}‡¶ü‡¶ø PDF\n"
            f"‚Ä¢ ‡¶¨‡¶æ‡¶ï‡¶ø: {files_remaining}‡¶ü‡¶ø PDF\n"
            "‚Ä¢ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶Æ‡¶æ‡¶®..."
        )
    
    if status == "merging":
        return "üîÑ **PDF ‡¶´‡¶æ‡¶á‡¶≤‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶è‡¶ï‡¶§‡ßç‡¶∞‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...**"
    
    if status == "uploading":
        return "üì§ **‡¶è‡¶ï‡¶§‡ßç‡¶∞‡¶ø‡¶§ PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá...**"
        
    if status == "downloading":
        # Calculate progress
        percentage = (current * 100) / total if total > 0 else 0
        elapsed_time = time.time() - start_time if start_time else 0
        speed = current / elapsed_time if elapsed_time > 0 else 0
        eta = (total - current) / speed if speed > 0 else 0
        
        # Generate progress bar
        progress_bar = "".join(
            "‚ñà" if i <= percentage / 5 else "‚ñë"
            for i in range(20)
        )
        
        return (
            f"üì• **‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá: {file_num}/{total_files}**\n\n"
            f"{progress_bar} {percentage:.1f}%\n"
            f"‚ö° ‡¶∏‡ßç‡¶™‡ßÄ‡¶°: {humanize.naturalsize(speed)}/s\n"
            f"‚è±Ô∏è ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶∏‡¶Æ‡¶Ø‡¶º: {humanize.naturaltime(eta, future=True)}"
        )
    
    return "‚è≥ **‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...**"

async def update_status(message: Message, merger: PDFMerger, current=0, total=0, start_time=None, file_num=None, total_files=None, status="waiting"):
    """Update status message."""
    try:
        user_id = message.from_user.id
        status_text = get_status_text(merger, current, total, start_time, file_num, total_files, status)
        
        if status in ["downloading", "uploading"]:
            # For progress updates, edit existing message
            if user_id in status_messages:
                try:
                    await status_messages[user_id].edit_text(status_text)
                    return
                except Exception as e:
                    print(f"Failed to edit message: {str(e)}")
        else:
            # For status changes, delete old and create new
            if user_id in status_messages:
                try:
                    await status_messages[user_id].delete()
                except:
                    pass
                del status_messages[user_id]
        
        # Create new message if needed
        if user_id not in status_messages:
            status_messages[user_id] = await message.reply_text(status_text)
            
    except Exception as e:
        print(f"Status update error: {str(e)}")

async def progress(current: int, total: int, message: Message, text: str, start_time: float, file_num=None, total_files=None):
    """Update progress with rate limiting."""
    try:
        user_id = message.from_user.id
        now = time.time()
        
        # Check if operation was cancelled
        if user_id not in user_states or not user_states[user_id].collecting:
            raise asyncio.CancelledError("Operation cancelled by user")
        
        # Update only if enough time has passed
        if user_id in user_states and (user_id not in last_progress_update or (now - last_progress_update.get(user_id, 0)) >= UPDATE_INTERVAL):
            last_progress_update[user_id] = now
            
            # Calculate progress
            percentage = (current * 100) / total if total > 0 else 0
            elapsed_time = time.time() - start_time if start_time else 0
            speed = current / elapsed_time if elapsed_time > 0 else 0
            eta = (total - current) / speed if speed > 0 else 0
            
            # Generate progress bar
            progress_bar = "".join(
                "‚ñà" if i <= percentage / 5 else "‚ñë"
                for i in range(20)
            )
            
            if text == "Downloading":
                status_text = (
                    f"üì• **‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá: {file_num}/{total_files}**\n\n"
                    f"{progress_bar} {percentage:.1f}%\n"
                    f"‚ö° ‡¶∏‡ßç‡¶™‡ßÄ‡¶°: {humanize.naturalsize(speed)}/s\n"
                    f"‚è±Ô∏è ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶∏‡¶Æ‡¶Ø‡¶º: {humanize.naturaltime(eta, future=True)}"
                )
            else:
                status_text = (
                    "üì§ **‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá**\n\n"
                    f"{progress_bar} {percentage:.1f}%\n"
                    f"‚ö° ‡¶∏‡ßç‡¶™‡ßÄ‡¶°: {humanize.naturalsize(speed)}/s\n"
                    f"‚è±Ô∏è ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶∏‡¶Æ‡¶Ø‡¶º: {humanize.naturaltime(eta, future=True)}"
                )
            
            # Update status message
            if user_id in status_messages:
                try:
                    await status_messages[user_id].edit_text(status_text)
                except Exception as e:
                    print(f"Failed to update progress: {str(e)}")
            
    except asyncio.CancelledError:
        raise  # Re-raise to cancel download
    except Exception as e:
        print(f"Progress update error: {str(e)}")

async def merge_command(client: Client, message: Message):
    """Handle /merge command."""
    try:
        user_id = message.from_user.id
        
        # Check if already processing
        if user_id in user_states and user_states[user_id].collecting:
            await message.reply_text(
                "‚ùå **‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ö‡¶≤‡¶Æ‡¶æ‡¶® ‡¶Ü‡¶õ‡ßá!**\n\n"
                "‡¶¶‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®,\n"
                "‡¶Ö‡¶•‡¶¨‡¶æ /allcancel ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
            )
            return
        
        # Get number of PDFs to merge
        cmd = message.text.split()
        if len(cmd) != 2:
            await message.reply_text(
                "üìö **PDF ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú‡¶æ‡¶∞ - ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ**\n\n"
                "**‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°:** `/merge ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ`\n"
                "**‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:** `/merge 3`\n\n"
                "**‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø:**\n"
                "1Ô∏è‚É£ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá /merge ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶∏‡ßç‡¶™‡ßá‡¶∏ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã PDF ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶∏‡ßá‡¶á ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®\n"
                "2Ô∏è‚É£ ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã‡¶∞ ‡¶™‡¶∞ ‡¶¨‡¶ü ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ö‡¶æ‡¶á‡¶¨‡ßá\n"
                "3Ô∏è‚É£ ‡¶è‡¶ï‡ßá ‡¶è‡¶ï‡ßá ‡¶∏‡¶¨ PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶®\n"
                "4Ô∏è‚É£ ‡¶∏‡¶¨ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶≤‡ßá ‡¶¨‡¶ü ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶æ PDF ‡¶¶‡¶ø‡¶¨‡ßá\n\n"
                "**‡¶∏‡ßÄ‡¶Æ‡¶æ‡¶¨‡¶¶‡ßç‡¶ß‡¶§‡¶æ:**\n"
                f"‚Ä¢ ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö {MAX_FILES}‡¶ü‡¶ø PDF ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá\n"
                f"‚Ä¢ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø PDF ‡¶´‡¶æ‡¶á‡¶≤ {humanize.naturalsize(MAX_FILE_SIZE)} ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá\n"
                f"‚Ä¢ ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶æ ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶∏‡¶æ‡¶á‡¶ú {humanize.naturalsize(MAX_MERGED_SIZE)} ‡¶è‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá ‡¶®‡¶æ\n\n"
                "**‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°:**\n"
                "‚Ä¢ /allcancel - ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶§‡ßá\n\n"
                "**‡¶ü‡¶ø‡¶™‡¶∏:**\n"
                "‚Ä¢ PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ï‡ßç‡¶∞‡¶Æ‡¶æ‡¶®‡ßÅ‡¶∏‡¶æ‡¶∞‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶¨‡ßá‡¶®, ‡¶è‡¶ï‡¶á ‡¶ï‡ßç‡¶∞‡¶Æ‡ßá ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶π‡¶¨‡ßá\n"
                "‚Ä¢ ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶≠‡¶æ‡¶≤‡ßã‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶®\n\n"
                "**üì∫ ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®:**\n"
                "‚Ä¢ https://www.youtube.com/shorts/ejnbUV0X9t0"
            )
            return
        
        num_pdfs = int(cmd[1])
        if num_pdfs <= 1:
            await message.reply_text("‚ùå ‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá ‡ß®‡¶ü‡¶ø PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
            return
            
        if num_pdfs > MAX_FILES:
            await message.reply_text(f"‚ùå ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö {MAX_FILES}‡¶ü‡¶ø PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶è‡¶ï‡¶§‡ßç‡¶∞‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§")
            return
        
        # Initialize merger for user
        user_id = message.from_user.id
        if user_id in user_states:
            user_states[user_id].reset()
            del user_states[user_id]
        
        user_states[user_id] = PDFMerger()
        merger = user_states[user_id]
        merger.required_files = num_pdfs
        merger.collecting = True
        
        await message.reply_text(
            f"üì• **{num_pdfs}‡¶ü‡¶ø PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶†‡¶æ‡¶®**\n\n"
            f"‚Ä¢ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡¶æ‡¶á‡¶ú: {humanize.naturalsize(MAX_FILE_SIZE)} ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá\n"
            "‚Ä¢ /allcancel - ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶§‡ßá"
        )
        
    except ValueError:
        await message.reply_text("‚ùå ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡ßà‡¶ß ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¶‡¶ø‡¶®‡•§")

async def handle_pdf(client: Client, message: Message):
    """Handle incoming PDF files."""
    try:
        user_id = message.from_user.id
        
        if user_id not in user_states or not user_states[user_id].collecting:
            return
        
        merger = user_states[user_id]
        
        # Check if it's a PDF file
        if not message.document or not message.document.file_name.lower().endswith('.pdf'):
            await message.reply_text("‚ùå ‡¶¶‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§")
            return
        
        if message.document.file_size > MAX_FILE_SIZE:
            await message.reply_text(
                f"‚ùå ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡¶æ‡¶á‡¶ú {humanize.naturalsize(MAX_FILE_SIZE)} ‡¶è‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá ‡¶®‡¶æ‡•§"
            )
            return
        
        # Get or create lock for this user
        if user_id not in message_locks:
            message_locks[user_id] = asyncio.Lock()
        
        # Process file under lock
        async with message_locks[user_id]:
            # Add file to queue
            merger.pdf_files.append({
                'message': message,
                'name': message.document.file_name,
                'size': message.document.file_size
            })
            
            # Update status message if still collecting
            if len(merger.pdf_files) < merger.required_files:
                await update_status(message, merger)
            
            # If all files received, start processing
            if len(merger.pdf_files) == merger.required_files:
                # Create user-specific directory
                user_download_dir = os.path.join(DOWNLOAD_DIR, str(user_id))
                if not os.path.exists(user_download_dir):
                    os.makedirs(user_download_dir)
                
                # Download all PDFs
                total_size = sum(f['size'] for f in merger.pdf_files)
                
                for i, pdf in enumerate(merger.pdf_files, 1):
                    # Check if operation was cancelled
                    if user_id not in user_states or not user_states[user_id].collecting:
                        return
                        
                    file_path = os.path.join(user_download_dir, f"pdf_{i}.pdf")
                    
                    # Download directly to disk
                    try:
                        start_time = time.time()
                        await pdf['message'].download(
                            file_path,
                            progress=progress,
                            progress_args=(
                                message,
                                "Downloading",
                                start_time,
                                i,
                                merger.required_files
                            )
                        )
                        merger.downloaded_files.append(file_path)
                    except Exception as e:
                        print(f"Download error: {str(e)}")
                        raise
                
                # Check if operation was cancelled
                if user_id not in user_states or not user_states[user_id].collecting:
                    return
                
                # Merge PDFs
                await update_status(message, merger, status="merging")
                merge_start = time.time()
                
                output_path = os.path.join(user_download_dir, "merged.pdf")
                
                # Use pikepdf for merging
                try:
                    with pikepdf.Pdf.new() as output_pdf:
                        for pdf_file in merger.downloaded_files:
                            with pikepdf.Pdf.open(pdf_file) as pdf:
                                output_pdf.pages.extend(pdf.pages)
                        output_pdf.save(output_path)
                except Exception as e:
                    raise Exception(f"PDF ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {str(e)}")
                
                merge_time = time.time() - merge_start
                
                # Send merged file
                await update_status(message, merger, status="uploading")
                
                # Create file list
                file_list = "\n".join([f"{i}. {pdf['name']}" for i, pdf in enumerate(merger.pdf_files, 1)])
                
                # Get actual output file size
                output_size = os.path.getsize(output_path) / (1024 * 1024)  # MB
                
                await message.reply_document(
                    document=output_path,
                    caption=(
                        "‚úÖ PDF ‡¶´‡¶æ‡¶á‡¶≤ ‡¶è‡¶ï‡¶§‡ßç‡¶∞‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!\n\n"
                        f"{file_list}\n\n"
                        f"‚Ä¢ ‡¶Æ‡ßã‡¶ü ‡¶´‡¶æ‡¶á‡¶≤: {len(merger.downloaded_files)}‡¶ü‡¶ø\n"
                        f"‚Ä¢ ‡¶Æ‡ßã‡¶ü ‡¶∏‡¶æ‡¶á‡¶ú: {output_size:.1f} MB\n"
                        f"‚Ä¢ ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ü‡¶æ‡¶á‡¶Æ: {merge_time:.1f}s"
                    ),
                    progress=progress,
                    progress_args=(
                        message,
                        "Uploading",
                        time.time()
                    )
                )
                
                # Clean up after successful send
                try:
                    if os.path.exists(user_download_dir):
                        for file in os.listdir(user_download_dir):
                            os.remove(os.path.join(user_download_dir, file))
                        os.rmdir(user_download_dir)
                except:
                    pass
                    
                # Clean up state
                if user_id in status_messages:
                    try:
                        await status_messages[user_id].delete()
                    except:
                        pass
                    del status_messages[user_id]
                if user_id in message_locks:
                    del message_locks[user_id]
                if user_id in user_states:
                    merger.reset()
                    del user_states[user_id]
                if user_id in last_progress_update:
                    del last_progress_update[user_id]
        
    except Exception as e:
        print(f"PDF handling error: {str(e)}")
        if user_id in user_states:
            user_states[user_id].reset()
            del user_states[user_id]
        if user_id in status_messages:
            try:
                await status_messages[user_id].delete()
            except:
                pass
            del status_messages[user_id]
        if user_id in message_locks:
            del message_locks[user_id]
        await message.reply_text(
            "‚ùå **‡¶è‡¶∞‡¶∞!**\n\n"
            f"‡¶ï‡¶æ‡¶∞‡¶£: {str(e)}\n"
            "‡¶¶‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
        )
